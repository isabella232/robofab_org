<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>
RoboFab Objects: RGlyph
</title>
<link href="../default.css" type="text/css" rel="stylesheet" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700' rel='stylesheet' type='text/css'>
</head><body>
<div class="leftcontent">
<p class="menu">
	<a href="../index.html">
		Home
	</a>
	
	
</p>
<p class="menu">
	<a href="../howto/index.html">
		How to's
	</a>
	<br />
	<a href="../talks09/index.html">
		Step by step intro
	</a>
	<br />
	<a href="index.html">
		Object reference
	</a>
</p>
</div>
<div id="titlepic">
<img src="../img/offdrawmodel_17.gif" alt="" border="0" />
</div>
<div class="content">
<h1>
RGlyph()
</h1>
<h3>
Usage
</h3>
<div class="pythonsource"><pre># robofab manual<br>#&nbsp; &nbsp; Glyph object<br>#&nbsp; &nbsp; Usage examples<br># start using the current font<br> <br><span class="py_res">from</span> <span class="py_key">robofab</span>.<span class="py_key">world</span> <span class="py_res">import</span> <span class="py_key">CurrentGlyph</span><br><span class="py_key">g</span> = <span class="py_key">CurrentGlyph</span>()<br> <br># suppose you've done the right imports<br># different ways of creating glyphs<br># a new empty glyph object<br><span class="py_key">g</span> = <span class="py_key">robofab</span>.<span class="py_key">world</span>.<span class="py_key">RGlyph</span>()<br> <br># a new empty fontlab glyph object<br><span class="py_key">g</span> = <span class="py_key">robofab</span>.<span class="py_key">objects</span>.<span class="py_key">objectsFL</span>.<span class="py_key">RGlyph</span>()<br> <br># a new empty robofab glyph object<br><span class="py_key">g</span> = <span class="py_key">robofab</span>.<span class="py_key">objects</span>.<span class="py_key">objectsRF</span>.<span class="py_key">RGlyph</span>()<br> <br># the easiest way to get a new glyph<br># is to ask a font to make you one:<br><span class="py_key">g</span> = <span class="py_key">aFontObject</span>[<span class="py_key">glyphName</span>]<br> <br></pre></div><div class="pythonsourcetitle"><a href="examples/usageGlyph.py" target="new"><strong>➔ Download this.</strong></a></div>
<h3>
Description
</h3>
<p>
	The RGlyph object represents a glyph, its parts and associated data. In FontLab RGlyph talks directly to a glyph in an open font. In NoneLab the RGlyph refers to data read from (and written to) a specific glif file in a UFO. RGlyph can be used as a list of RContours. When RGlyph is obtained from a RoboFab font object (see examples), the font is the
	<b>
	parent
	</b>
	object of the glyph.
	<h3>
	Attributes
	</h3>
</p>
<p>
	<ul>
		<li>
			<strong>
			components</strong>: a list of the
			<a href="component.html">
			Component</a>s in this glyph.
		</li>
		<li>
			<strong>
			anchors</strong>: a list of the
			<a href="anchor.html">
			Anchor</a>s in this glyph.
		</li>
		<li>
			<strong>
			len(aGlyph)</strong>: the number of contours.
		</li>
		<li>
			<strong>
			aGlyph[index]</strong>: get the
			<a href="contour.html">
				Contour
			</a>
			object at index.
		</li>
		<li>
			<strong>
			width</strong>: the horizontal advance width of the glyph.
		</li>
		<li>
			<strong>
			leftMargin</strong>: the left margin of the glyph.
		</li>
		<li>
			<strong>
			rightMargin</strong>: the right margin of the glyph.
		</li>
		<li>
			<strong>
			name</strong>: the glyph name.
		</li>
		<li>
			<strong>
			unicode</strong>: the unicode value for this glyph, integer.
		</li>
		<li>
			<strong>
			note</strong>: a place for a short string, a note about this glyph.
		</li>
		<li>
			<strong>
			unicodes</strong>: a list of unicodes value for this glyph. Not all applications and editors support multiple unicode values for a glyph. Assume that <strong>glyph.unicode == glyph.unicodes[0]</strong>
		</li>
		<li>
			<strong>
			box</strong>: the bounding box. The values are (xMin, yMin, xMax, yMax). Note: these values represent the actual measurements of the shape of the glyph. They're usually different from the rectangle described by
			<strong>
			glyph.width / font.info.unitsPerEm
			</strong>
		</li>
		<li>
			<strong>
			+ - *</strong>: math operators work on glyphs. See
			<a href="../howto/glyphmath.html">
			how to glyphmath</a>.
		</li>
		<li>
			<strong>
			lib</strong>: the glyph's lib, an
			<a href="lib.html">
			RLib</a>. See also
			<a href="../howto/usethelib.html">
			how to use the lib</a>.
		</li>
	</ul>
</p>
<h3>
Attribute examples
</h3>
<div class="pythonsource"><pre># robofab manual<br>#&nbsp; &nbsp; Glyph object<br>#&nbsp; &nbsp; attribute examples<br> <br><span class="py_res">from</span> <span class="py_key">robofab</span>.<span class="py_key">world</span> <span class="py_res">import</span> <span class="py_key">CurrentFont</span>, <span class="py_key">CurrentGlyph</span><br><span class="py_key">f</span> = <span class="py_key">CurrentFont</span>()<br> <br># create a glyph object by asking the font<br><span class="py_key">g</span> = <span class="py_key">f</span>[<span class="py_str">"Adieresis"</span>]<br> <br># alternatively, create a glyph object for the current glyph<br><span class="py_key">g</span> = <span class="py_key">CurrentGlyph</span>()<br> <br># get the width<br><span class="py_res">print</span> <span class="py_key">g</span>.<span class="py_key">width</span><br> <br># get the name<br><span class="py_res">print</span> <span class="py_key">g</span>.<span class="py_key">name</span><br> <br># a&nbsp; list of unicode values for this glyph. Can be more than 1!<br><span class="py_res">print</span> <span class="py_key">g</span>.<span class="py_key">unicodes</span><br> <br># set the width<br><span class="py_key">g</span>.<span class="py_key">width</span> = <span class="py_num">1000</span><br><span class="py_res">print</span> <span class="py_key">g</span>.<span class="py_key">width</span><br> <br># get the number of contours in a glyph<br># by getting&nbsp; its length<br><span class="py_res">print</span> <span class="py_key">len</span>(<span class="py_key">g</span>)<br></pre></div><div class="pythonsourcetitle"><a href="examples/glyphAttributes.py" target="new"><strong>➔ Download this.</strong></a></div>
<div class="pythonoutput"><pre><span class="py_num">230</span><br><span class="py_key">Adieresis</span><br>[<span class="py_num">123</span>, <span class="py_num">345</span>]<br><span class="py_num">1000</span><br><span class="py_num">4</span></pre></div>
<h3>
Methods
</h3>
<p>
	<ul>
		<li>
			<strong>
			getParent()</strong>: Return the parent of this glyph, the font object it belongs to. The method returns
			<strong>
			None
			</strong>
			if there is none.
		</li>
		<li>
			<strong>
			appendComponent(glyphName, (offsetX=0, offsetY=0), (scaleX=1, scaleY=1))</strong>: add a component to the glyph. Optional values for offset and scale.
		</li>
		<li>
			<strong>
			appendContour(aContour)</strong>: add a contour to the glyph.
		</li>
		<li>
			<strong>
			removeComponent(componentObject)</strong>: remove a component from the glyph.
		</li>
		<li>
			<strong>
			appendGlyph(aGlyph, (offsetX=0, offsetY=0))</strong>: add a whole glyph. This adds all the contours, anchors and components to the glyph.
		</li>
		
		<li><strong>appendAnchor(name, position)</strong>: create a new anchor in this glyph with <strong>name</strong> at <strong>position</strong>.				</li>
		
		
		<li><strong>removeAnchor(anchor)</strong>: remove this anchor from the glyph. This only works
			if the glyph does not have anchors with duplicate names
		in exactly the same location with the same mark.				</li>
		
		
		
		
		<li>
			<strong>
			autoUnicodes()</strong>: try to find unicode values for this glyph. This method tries to match the glyph name to a known value.
		</li>
		<li>
			<strong>
			copy()</strong>: returns a deep copy of this glyph. That means that all parts of the glyph: contours, components, anchors etc. are duplicated.
		</li>
		<li>
			<strong>
			correctDirection()</strong>: correct the direction of all contours in this glyphs.
		</li>
		<li>
			<strong>
			autoContourOrder()</strong>: automatically order the contours based on (in this order): the point count of the contours, the segment count of the contours, the x value of the center of the contours, the y value of the center of the contours and the surface of the bounding box of the contours.
		</li>
		<li>
			<strong>
			pointInside((x, y))</strong>: returns True if the point is inside the "black" area of the glyph or False if the point is inside the "white" area of the glyph.
		</li>
		<li>
			<strong>
			draw(aPen)</strong>: get this glyph to draw itself with the pen on offer.
		</li>
		<li>
			<strong>
			drawPoints(aPointsPen)</strong>: get this glyph to draw itself with the points pen on offer. For differences between Pen and PointsPen see here
			<a href="pen.html">
			Pens</a>.
		</li>
		<li>
			<strong>
			getPen()
			</strong>
			returns an appropriate Pen object to draw in this glyph.
		</li>
		<li>
			<strong>
			getPointPen()
			</strong>
			returns an appropriate Point Pen object to draw in this glyph.
		</li>
		<li>
			<strong>
			interpolate(factor, minGlyph, maxGlyph, suppressError=True, analyzeOnly=False)</strong>: make this glyph the interpolation between minGlyph and maxGlyph by factor. When
			<b>
			suppressError
			</b>
			is True (the default value) this method will not complain if the interpolation is not possible. When
			<b>
			analyzeOnly
			</b>
			is True (default is False), this method will only analyze if the interpolation is possible and provide a report if something is wrong. See also
			<a href="../howto/interpolate.html">
				how to interpolate.
			</a>
		</li>
		<li>
			<strong>
			isCompatible(anotherGlyph, report=True)</strong>: returns True if the glyph has a compatible point structure as anotherGlyph. When report is True, isCompatible also returns a report on what the problems could be. See also
			<a href="../howto/interpolate.html">
				how to interpolate.
			</a>
		</li>
		<li>
			<strong>
			isEmpty()</strong>: returns True when the glyph does not contain any contours, components or anchors.
		</li>
		<li>
			<strong>
			move(x, y), contours=True, components=True, anchors=True)</strong>: Move a glyph's items that are flagged as True
		</li>
		<li>
			<strong>
			scale((x, y), center=(0, 0))</strong>: Scale the glyph by x and y. Optionally set the center of the scale.
		</li>
		<li>
			<strong>
			rotate(angle, offset=None)</strong>: Rotate the glyph by angle (in degrees). Optionally set an offset value.
		</li>
		<li>
			<strong>
			skew(angle, offset=None)</strong>: Skew the glyph by angle (in degrees). Optionally set an offset value.
		</li>
		<li>
			<strong>
			rasterize(cellSize=50, xMin=None, yMin=None, xMax=None, yMax=None)</strong>: Slice the glyph into a grid based on the cell size. It returns a list of lists containing bool values that indicate the black (True) or white (False) value of that particular cell. These lists are arranged from top to bottom of the glyph and proceed from left to right. This is an expensive operation!
		</li>
	</ul>
</p>
<h3>
Method examples
</h3>
<div class="pythonsource"><pre># robofab manual<br>#&nbsp; &nbsp; Glyph object<br>#&nbsp; &nbsp; method examples<br> <br># get a glyph object from a font<br><span class="py_key">f</span> = <span class="py_key">CurrentFont</span>()<br><span class="py_key">g</span> = <span class="py_key">f</span>[<span class="py_str">"A"</span>]<br><span class="py_res">print</span> <span class="py_key">g</span><br> <br># move the glyph 10 units to the right, and 200 units up:<br><span class="py_key">g</span> = <span class="py_key">f</span>[<span class="py_str">"a"</span>]<br><span class="py_key">g</span>.<span class="py_key">move</span>((<span class="py_num">10</span>, <span class="py_num">200</span>))<br></pre></div><div class="pythonsourcetitle"><a href="examples/glyphMethods.py" target="new"><strong>➔ Download this.</strong></a></div>
<h1>
FontLab
</h1>
<h3>
Methods
</h3>
<p>
	Glyph methods only available in FontLab.
	<ul>
		<li>
			<strong>
			removeOverlap()</strong>: remove overlap in this glyph.
		</li>
		<li>
			<strong>naked()</strong>: return the wrapped fontlab glyph object itself.
			This can be useful if you want to set very specific values in the fontlab font that aren't wrapped or handled by RoboFab objects.
		</li>
		<li>
			<strong>update()</strong>: tell FontLab to update all references to this glyph. Call this after you've changed something in the glyph object and you want these changes to be seen in the application. If you're calling glyph.update() a lot, for instance in a loop, consider calling it only once after the loop is done. You can also call font.update() if you've changed several glyphs at once. Calling update() makes a script slower.
		</li>
		<li>
			<strong>
			getVGuides()</strong>: Return a list of wrapped vertical guides in this RGlyph.
		</li>
		<li>
			<strong>
			getHGuides()</strong>: Return a list of wrapped horizontal guides in this RGlyph.
		</li>
		<li>
			<strong>
			appendVGuide(x)</strong>: Add a vertical guide at x in this RGlyph.
		</li>
		<li>
			<strong>
			appendHGuide(y)</strong>: Add a horizontal guide at y in this RGlyph.
		</li>
		<li>
			<strong>
			clearVGuides()</strong>: Remove vertical guides from this RGlyph.
		</li>
		<li>
			<strong>
			clearHGuides()</strong>: Remove horizontal guides from this RGlyph.
		</li>
	</ul>
</p>
<h3>
Useful
</h3>
<div class="pythonsource"><pre># robofab manual<br>#&nbsp; &nbsp; Glyph object<br>#&nbsp; &nbsp; method examples<br> <br>#&nbsp; &nbsp; In FontLab the baseglyph of a component can't be changed easily.<br>#&nbsp; &nbsp; This assumes that there will only be<br>#&nbsp; &nbsp; one component that needs to be remapped.<br> <br><span class="py_res">def</span> <span class="py_def">remapComponent</span>(<span class="py_key">glyph</span>, <span class="py_key">oldBaseGlyph</span>, <span class="py_key">newBaseGlyph</span>):<br>&nbsp; &nbsp; <span class="py_key">foundComponent</span> = <span class="py_key">None</span><br>&nbsp; &nbsp; <span class="py_res">for</span> <span class="py_key">component</span> <span class="py_res">in</span> <span class="py_key">glyph</span>.<span class="py_key">components</span>:<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="py_res">if</span> <span class="py_key">component</span>.<span class="py_key">baseGlyph</span> = <span class="py_key">oldBaseGlyph</span>:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="py_key">foundComponent</span> = <span class="py_key">component</span><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="py_res">break</span><br>&nbsp; &nbsp; <span class="py_res">if</span> <span class="py_key">foundComponent</span> <span class="py_res">is</span> <span class="py_key">None</span>:<br>&nbsp; &nbsp; &nbsp; &nbsp; <span class="py_res">return</span><br>&nbsp; &nbsp; <span class="py_key">offset</span> = <span class="py_key">foundComponent</span>.<span class="py_key">offset</span><br>&nbsp; &nbsp; <span class="py_key">scale</span> = <span class="py_key">foundComponent</span>.<span class="py_key">scale</span><br>&nbsp; &nbsp; <span class="py_key">glyph</span>.<span class="py_key">removeComponent</span>(<span class="py_key">component</span>)<br>&nbsp; &nbsp; <span class="py_key">glyph</span>.<span class="py_key">appendComponent</span>(<span class="py_key">newBaseGlyph</span>, <span class="py_key">offset</span>=<span class="py_key">offset</span>, <span class="py_key">scale</span>=<span class="py_key">scale</span>)<br> <br></pre></div><div class="pythonsourcetitle"><a href="examples/remapComponent.py" target="new"><strong>➔ Download this.</strong></a></div>
</div>
</body></html>